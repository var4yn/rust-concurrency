<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rust::concurrency</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; }
    body { background: #0d0f14; font-family: 'JetBrains Mono','Fira Code','Cascadia Code',monospace; color: #c8d0e0; }
    ::-webkit-scrollbar { width: 5px; height: 5px; }
    ::-webkit-scrollbar-track { background: #0d0f14; }
    ::-webkit-scrollbar-thumb { background: #2a3040; border-radius: 3px; }
    button { font-family: inherit; }
  </style>
</head>
<body>
  <div id="app"></div>
  <script>
const data = {
  categories: [
    {
      id: "ownership",
      label: "Shared Ownership",
      color: "#e8793a",
      items: [
        {
          name: "Rc<T>",
          subtitle: "Reference Counted",
          thread_safe: false,
          short: "Несколько владельцев, один поток",
          etymology: `RC = Reference Counted — «подсчёт ссылок».

Название буквально описывает механизм: внутри хранится счётчик (usize), который растёт при каждом clone() и уменьшается при каждом drop(). Когда счётчик достигает нуля — данные освобождаются.

Это классический алгоритм управления памятью, известный с 1960-х. В Python это основной механизм GC. В С++ — std::shared_ptr. В Rust — Rc<T>.

Почему не «SharedPtr»? Rust предпочитает имена, раскрывающие реализацию, а не абстрактное назначение. «Reference Counted» честно говорит как это работает под капотом.`,
          what: "Умный указатель с подсчётом ссылок. Позволяет нескольким переменным владеть одним значением.",
          why: "Когда нужно разделить владение данными, но вы точно знаете что работаете в одном потоке.",
          how: "::new(value) создаёт экземпляр, ::clone(&ptr) клонирует — увеличивает счётчик. Данные дропаются когда счётчик = 0.",
          danger: "Не Send, не Sync — нельзя отправить в другой поток. В многопоточке → Arc. Циклические ссылки → утечка памяти (используй Weak).",
          example: `use std::rc::Rc;

let a = Rc::new(5);
let b = Rc::clone(&a); // счётчик = 2
println!("{}", Rc::strong_count(&a)); // 2
drop(b); // счётчик = 1
// drop(a) → счётчик = 0 → память освобождена`,
          interview: [
            "Чем Rc отличается от Arc? — Arc использует атомарные операции для счётчика, Rc — нет. Arc безопасен для потоков, Rc — нет, зато чуть быстрее.",
            "Может ли Rc создать циклическую ссылку? — Да, и это вызовет утечку памяти. Решение: Weak<T> для обратных ссылок.",
            "Почему Rc не Send? — Операции с счётчиком не атомарны. Если два потока одновременно клонируют/дропают Rc — data race на счётчике.",
          ],
        },
        {
          name: "Arc<T>",
          subtitle: "Atomic Reference Counted",
          thread_safe: true,
          short: "Несколько владельцев, много потоков",
          etymology: `ARC = Atomic Reference Counted.

«Atomic» — ключевое слово. Атомарная операция неделима: процессор выполняет её целиком, без возможности прерывания другим потоком на полуслове.

Проблема Rc в многопоточке: счётчик — это обычный usize. Если два потока одновременно делают clone() (read-modify-write в три шага), между шагами потоки могут перемешаться → счётчик неверный → double free или утечка.

Arc заменяет usize на AtomicUsize. Операции fetch_add/fetch_sub — аппаратные инструкции CPU (LOCK XADD на x86), физически неразделимые.

Буква A стоит первой намеренно: Arc = Rc + Atomic. Всё остальное идентично.`,
          what: "То же что Rc, но счётчик ссылок изменяется атомарно — безопасно между потоками.",
          why: "Нужно разделить данные между потоками. Для мутации оборачивается в Mutex или RwLock.",
          how: "::new(val) создаёт, ::clone(&ptr) клонирует — атомарный инкремент счётчика. Реализует Send + Sync если T: Send + Sync.",
          danger: "Чуть медленнее Rc из-за атомарных операций. Сам по себе не даёт мутабельность — нужен Arc<Mutex<T>>.",
          example: `use std::sync::Arc;
use std::thread;

let data = Arc::new(vec![1, 2, 3]);
let data2 = Arc::clone(&data);

let handle = thread::spawn(move || {
    println!("{:?}", data2); // data2 moved в поток
});
handle.join().unwrap();
println!("{:?}", data); // data всё ещё жива здесь`,
          interview: [
            "Зачем Arc если есть Rc? — Rc не Send/Sync, Arc — да. Arc чуть медленнее из-за атомарных операций на счётчике.",
            "Arc<T> даёт мутабельность? — Нет. Только Arc<Mutex<T>> или Arc<RwLock<T>>.",
            "Что такое Weak в Arc? — Слабые ссылки не увеличивают strong_count и не продлевают жизнь объекта. upgrade() → Option<Arc<T>>. Нужны для разрыва циклов.",
            "Почему Arc::clone явно, а не .clone()? — Работает и .clone(). Arc::clone(&x) сигнализирует читателю: это дёшево (не deep copy), просто инкремент счётчика.",
          ],
        },
        {
          name: "Weak<T>",
          subtitle: "Weak Reference",
          thread_safe: true,
          short: "Слабая ссылка — не продлевает жизнь объекта",
          etymology: `WEAK = «слабый» в противовес «сильному» (strong) владению.

Терминология из теории управления памятью: strong reference удерживает объект живым (инкрементирует strong_count), weak reference — нет (инкрементирует только weak_count).

Это решение проблемы циклических ссылок, открытой при создании Lisp: если A владеет B и B владеет A через Rc/Arc — оба никогда не дропнутся. Weak разрывает цикл: B держит слабую ссылку на A, которая не мешает A умереть.

Weak::upgrade() возвращает Option<Arc<T>> — Some если объект ещё жив, None если уже дропнут. Это честно: «я не уверен что он ещё существует».`,
          what: "Не-владеющая ссылка. Не увеличивает strong_count. Получается через Arc::downgrade(&arc).",
          why: "Разрыв циклических ссылок. Например, дерево: родитель Arc-владеет детьми, дети держат слабую ссылку на родителя.",
          how: "Arc::downgrade(&ptr) → слабая ссылка. .upgrade() → Option<Arc<T>>. Если strong_count = 0 — upgrade вернёт None.",
          danger: "upgrade() может вернуть None — всегда обрабатывай оба варианта.",
          example: `use std::sync::{Arc, Weak};

let strong = Arc::new(42);
let weak: Weak<i32> = Arc::downgrade(&strong);

println!("{:?}", weak.upgrade()); // Some(42)
drop(strong); // strong_count → 0
println!("{:?}", weak.upgrade()); // None — объект умер`,
          interview: [
            "Когда нужен Weak? — При создании графов, деревьев с обратными ссылками, observer-паттернах — везде где есть риск цикла.",
            "Что будет если дропнуть все Arc но остались Weak? — Данные освобождаются (strong_count = 0). Weak::upgrade() → None. Сам аллокатор живёт пока weak_count > 0.",
          ],
        },
      ],
    },
    {
      id: "interior",
      label: "Interior Mutability",
      color: "#4a9eff",
      items: [
        {
          name: "Cell<T>",
          subtitle: "Mutable memory location",
          thread_safe: false,
          short: "Мутация Copy-типов без &mut",
          etymology: `CELL = «ячейка» памяти.

Метафора из биологии/химии: ячейка — изолированный контейнер, содержимое которого можно заменить целиком, не разбирая на части.

Cell<T> именно так и работает: нельзя получить ссылку внутрь (&T или &mut T). Только set() — заменить целиком — и get() — скопировать целиком. Это и есть «ячейка»: непрозрачный контейнер с атомарной заменой содержимого.

Именно поэтому Cell работает только с Copy-типами: get() обязан копировать значение, иначе нарушится модель владения.`,
          what: "Позволяет менять значение через shared reference (&self). Работает только с Copy-типами.",
          why: "Когда нужно изменять примитив через &self без overhead RefCell (нет runtime borrow-чекинга).",
          how: ".get() копирует значение, .set(val) заменяет целиком. Нет borrow-чекинга — нет паники. Нет ссылок внутрь.",
          danger: "Только Copy-типы. Не Send — только для одного потока. Нельзя получить &T или &mut T.",
          example: `use std::cell::Cell;

struct Config {
    debug: Cell<bool>,
    calls: Cell<u32>,
}

impl Config {
    fn inc(&self) { // &self, не &mut self!
        self.calls.set(self.calls.get() + 1);
    }
}`,
          interview: [
            "Cell vs RefCell? — Cell для Copy-типов (только set/get, нет ссылок), RefCell для любых типов через borrow()/borrow_mut().",
            "Почему Cell не требует unsafe? — Не даёт ссылок внутрь. Нет ссылки — нет aliasing — нет UB.",
          ],
        },
        {
          name: "RefCell<T>",
          subtitle: "Ref + Cell",
          thread_safe: false,
          short: "Мутация любых типов, borrow-чекинг в рантайме",
          etymology: `REF + CELL = RefCell.

Это буквально сложение двух слов:
• REF — reference. В отличие от Cell, RefCell позволяет получить ссылки внутрь: Ref<T> (= &T) и RefMut<T> (= &mut T).
• CELL — та же «ячейка» interior mutability. Можно менять содержимое через &self.

Смысл названия: «ячейка, которая выдаёт ссылки». Но ссылки не могут существовать по обычным правилам Rust (compile-time), поэтому RefCell переносит эти правила в runtime: внутри хранится флаг-счётчик состояния (BorrowState).

В Rust-сообществе говорят: RefCell делает borrow-checker «ленивым» — не отказывает при компиляции, но может паниковать при запуске.`,
          what: "Переносит проверки borrowing из compile-time в runtime. Позволяет получить &mut T через &self.",
          why: "Когда borrow-checker мешает, а вы логически уверены в корректности. Граф, дерево, mock-объекты в тестах.",
          how: "borrow() → Guard на чтение, borrow_mut() → Guard на запись. N читателей ИЛИ 1 писатель. Нарушение → panic.",
          danger: "Паника в рантайме если нарушить правила borrowing. Не Sync — только один поток. try_borrow_mut() → Result вместо паники.",
          example: `use std::cell::RefCell;

let data = RefCell::new(vec![1, 2, 3]);

{
    let mut v = data.borrow_mut();
    v.push(4);
} // RefMut дропается — лок снят

println!("{:?}", data.borrow()); // [1, 2, 3, 4]

// ПАНИКА:
// let r = data.borrow();
// let rw = data.borrow_mut(); // panic!`,
          interview: [
            "Когда RefCell паникует? — Когда берёшь borrow_mut() пока активен borrow() или другой borrow_mut().",
            "RefCell vs Mutex? — RefCell для одного потока (нет системного лока, только флаг), Mutex для многопоточки (OS-примитив).",
            "try_borrow_mut() зачем? — Возвращает Result вместо паники. Полезно когда нельзя гарантировать порядок заимствований.",
            "Rc<RefCell<T>> — что это? — Классическая пара: Rc даёт разделённое владение, RefCell — мутабельность. Эквивалент Arc<Mutex<T>> для одного потока.",
          ],
        },
      ],
    },
    {
      id: "sync",
      label: "Синхронизация потоков",
      color: "#6bcf7f",
      items: [
        {
          name: "Mutex<T>",
          subtitle: "Mutual Exclusion",
          thread_safe: true,
          short: "Один поток за раз — эксклюзивный доступ",
          etymology: `MUTEX = Mutual Exclusion — «взаимное исключение».

Термин придуман Эдсгером Дейкстрой в 1960-х при разработке теории параллельного программирования.

«Взаимное» — потоки взаимно исключают друг друга из критической секции. «Исключение» — один поток исключает всех остальных пока держит лок.

В других языках: synchronized (Java), lock (C#), pthread_mutex (C). Концепция везде одна — термин с 1965 года.

Особенность Rust: Mutex<T> — это контейнер. Данные T физически живут внутри Mutex. Невозможно обратиться к T в обход лока — компилятор не даст. В C/Java Mutex и данные существуют отдельно, и программист может «забыть» взять лок.`,
          what: "Примитив синхронизации. Только один поток может держать лок одновременно. Данные T живут внутри.",
          why: "Когда несколько потоков должны читать и писать общие данные.",
          how: "lock() → Guard<T> (реализует DerefMut, доступ через *). Guard снимает лок при дропе (RAII).",
          danger: "Deadlock: два потока ждут локи друг у друга. Poisoned mutex: поток паниковал держа лок → lock() вернёт Err.",
          example: `use std::sync::{Arc, Mutex};
use std::thread;

let counter = Arc::new(Mutex::new(0_i32));

let handles: Vec<_> = (0..8).map(|_| {
    let c = Arc::clone(&counter);
    thread::spawn(move || {
        let mut n = c.lock().unwrap();
        *n += 1;
        // MutexGuard дропается → лок снят
    })
}).collect();

for h in handles { h.join().unwrap(); }
println!("{}", *counter.lock().unwrap()); // 8`,
          interview: [
            "Что такое poisoned mutex? — Если поток паникует держа лок, Mutex помечается отравленным. Другие потоки получат Err из lock(). Данные можно извлечь через .unwrap_or_else(|e| e.into_inner()).",
            "Mutex vs RwLock? — Mutex: один поток одновременно. RwLock: много читателей ИЛИ один писатель.",
            "Deadlock в Rust возможен? — Да. Компилятор защищает от data race, но не от deadlock.",
            "Почему Mutex<T> лучше чем Mutex отдельно от T (как в C)? — Невозможно получить &mut T без лока — компилятор не позволит.",
          ],
        },
        {
          name: "RwLock<T>",
          subtitle: "Read-Write Lock",
          thread_safe: true,
          short: "Много читателей ИЛИ один писатель",
          etymology: `RWLOCK = Read-Write Lock — «лок чтения-записи».

Название описывает два режима: Read (чтение) и Write (запись). Классический примитив из ОС 1970-х для задачи «читатели-писатели» (Readers-Writers Problem, тоже Дейкстра).

Идея: чтение безопасно параллельно — читатели не мешают друг другу. Запись требует эксклюзии.

Mutex — частный случай RwLock где read = write (всегда эксклюзивно).

В POSIX: pthread_rwlock. В Java: ReadWriteLock. В C++: std::shared_mutex. Rust выбрал более описательное имя, раскрывающее семантику.`,
          what: "Как Mutex, но разрешает нескольким потокам одновременно читать. Запись — эксклюзивна.",
          why: "Когда чтений намного больше чем записей. Даёт лучший throughput чем Mutex при read-heavy нагрузке.",
          how: "read() → ReadGuard (много одновременно), write() → WriteGuard (один, блокирует всех).",
          danger: "Writer starvation: постоянный поток читателей не даёт писателю взять лок. Deadlock тоже возможен.",
          example: `use std::sync::{Arc, RwLock};
use std::thread;

let config = Arc::new(RwLock::new(vec!["default"]));

// Много читателей одновременно — OK
for _ in 0..5 {
    let c = Arc::clone(&config);
    thread::spawn(move || {
        let r = c.read().unwrap(); // все 5 держат одновременно
        println!("{:?}", *r);
    });
}

// Один писатель — ждёт всех читателей
config.write().unwrap().push("new_value");`,
          interview: [
            "Когда RwLock лучше Mutex? — Когда read >> write. При равном соотношении Mutex может быть быстрее.",
            "Что такое writer starvation? — Писатель вечно ждёт пока поток читателей не отпустит лок.",
            "Может ли RwLock задедлочиться? — Да. Например: поток держит read lock и пытается взять write lock на том же RwLock.",
          ],
        },
        {
          name: "Condvar",
          subtitle: "Condition Variable",
          thread_safe: true,
          short: "Ожидание условия с атомарным снятием лока",
          etymology: `CONDVAR = Condition Variable — «переменная условия».

Термин из классики Хоара (1974, «Monitors: An Operating System Structuring Concept»).

«Переменная» — потому что это примитив, ассоциированный с некоторым условием (предикатом) над данными. Поток «ждёт переменную» — ждёт пока условие не станет истинным.

Ключевое: Condvar не хранит само условие — это лишь механизм оповещения. Программист сам проверяет условие в цикле while.

Condvar всегда используется вместе с Mutex — это неотделимая пара. «Переменная условия» точно описывает семантику: не состояние, а точка синхронизации вокруг изменения состояния.`,
          what: "Позволяет потоку ждать пока условие не станет истинным, атомарно освобождая Mutex.",
          why: "Producer-Consumer паттерн. Вместо busy-waiting поток спит и просыпается по сигналу.",
          how: "wait(guard) снимает лок и спит атомарно. notify_one()/notify_all() будит потоки. Всегда проверять условие в while.",
          danger: "Spurious wakeups — поток может проснуться без сигнала. Всегда while !condition { wait }, никогда if.",
          example: `use std::sync::{Arc, Mutex, Condvar};
use std::thread;

let pair = Arc::new((Mutex::new(false), Condvar::new()));
let pair2 = Arc::clone(&pair);

thread::spawn(move || {
    let (lock, cvar) = &*pair2;
    let mut ready = lock.lock().unwrap();
    *ready = true;
    cvar.notify_one();
});

let (lock, cvar) = &*pair;
let mut ready = lock.lock().unwrap();
while !*ready { // while — защита от spurious wakeup!
    ready = cvar.wait(ready).unwrap();
}
println!("Получили сигнал!");`,
          interview: [
            "Что такое spurious wakeup? — Поток просыпается без notify. Это легальное поведение POSIX. Защита: while !condition.",
            "Почему Condvar всегда с Mutex? — wait() должен атомарно снять лок и заснуть. Иначе notify может прийти до засыпания.",
            "notify_one vs notify_all? — notify_one будит один случайный поток, notify_all — всех.",
          ],
        },
        {
          name: "Atomic",
          subtitle: "AtomicUsize, AtomicBool...",
          thread_safe: true,
          short: "Lock-free операции над примитивами",
          etymology: `ATOMIC = «атомарный», от греческого atomos — «неделимый».

Атом в физике — мельчайшая частица которую нельзя разделить. В computer science «атомарная операция» — операция которую нельзя прервать на полпути.

Проблема: простое i += 1 в реальности три машинные инструкции: LOAD, ADD, STORE. Между ними другой поток может сделать то же самое — одно обновление потеряется (race condition).

Атомарная операция FETCH_ADD делает все три действия как одну неделимую инструкцию (LOCK XADD на x86). Никакой другой поток не может «влезть» между ними.

Термин используется везде: std::atomic (C++), java.util.concurrent.atomic, sync/atomic (Go). Rust следует общепринятому термину.`,
          what: "Атомарные операции над примитивными типами без блокировок. В std::sync::atomic.",
          why: "Счётчики, флаги, статусы между потоками. Быстрее Mutex, нет deadlock.",
          how: "load/store/fetch_add/compare_exchange с указанием Ordering. SeqCst — безопасный дефолт.",
          danger: "Сложно выбрать правильный Ordering. Не подходит для сложных структур данных.",
          example: `use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::Arc;
use std::thread;

let hits = Arc::new(AtomicUsize::new(0));

let handles: Vec<_> = (0..100).map(|_| {
    let h = Arc::clone(&hits);
    thread::spawn(move || {
        h.fetch_add(1, Ordering::SeqCst);
    })
}).collect();
for h in handles { h.join().unwrap(); }
println!("{}", hits.load(Ordering::SeqCst)); // 100

// Ordering шпаргалка:
// Relaxed  — только атомарность, нет гарантий порядка
// Acquire  — при load: все записи до Release видны
// Release  — при store: виден читателю с Acquire
// SeqCst   — строгий глобальный порядок (безопасный дефолт)`,
          interview: [
            "Что такое Ordering::SeqCst? — Sequentially Consistent. Все потоки видят атомарные операции в одном порядке. Самый безопасный, чуть медленнее.",
            "Atomic vs Mutex? — Atomic: только примитивы, lock-free, быстрее. Mutex: любые данные, проще логика.",
            "Что такое compare_exchange? — CAS (Compare And Swap): атомарно проверяет current == expected, если да — записывает new. Основа lock-free алгоритмов.",
            "Почему Relaxed быстрее SeqCst? — Relaxed не требует memory barrier (аппаратной инструкции синхронизации кешей CPU).",
          ],
        },
        {
          name: "Barrier",
          subtitle: "Synchronization Barrier",
          thread_safe: true,
          short: "Все потоки ждут друг друга в точке встречи",
          etymology: `BARRIER = «барьер», «преграда».

Метафора: все потоки бегут к барьеру. Первые добежавшие останавливаются и ждут. Только когда все N потоков достигли барьера — он поднимается и все продолжают.

Визуально: ---→  --→  ----→  | БАРЬЕР |  →  →  →

Это паттерн fork-join: разделить работу между потоками, подождать всех, собрать результаты.

В параллельных вычислениях барьерная синхронизация — фундаментальный паттерн (MPI_Barrier в HPC, CyclicBarrier в Java). Название «barrier» — отраслевой стандарт.`,
          what: "Точка синхронизации: все N потоков должны достичь барьера, прежде чем любой из них продолжит.",
          why: "Параллельные вычисления где нужно дождаться всех фаз. Разделить матрицу → считать → собрать.",
          how: "::new(N) создаёт точку синхронизации на N потоков. .wait() блокирует пока все N не вызовут .wait().",
          danger: "Если один поток не дойдёт до барьера (паника, ранний выход) — остальные зависнут навсегда.",
          example: `use std::sync::{Arc, Barrier};
use std::thread;

let barrier = Arc::new(Barrier::new(4));

let handles: Vec<_> = (0..4).map(|i| {
    let b = Arc::clone(&barrier);
    thread::spawn(move || {
        println!("Поток {} начал", i);
        // ... вычисления ...
        b.wait(); // ждём всех 4 потоков
        println!("Поток {} продолжил", i);
    })
}).collect();

for h in handles { h.join().unwrap(); }`,
          interview: [
            "Barrier vs Condvar? — Barrier: ждём ровно N потоков, семантика «встретились все». Condvar: ждём произвольного условия, более гибко.",
            "Что вернёт wait()? — BarrierWaitResult. Один из потоков получит is_leader() = true — можно использовать для выбора лидера фазы.",
          ],
        },
        {
          name: "OnceLock<T>",
          subtitle: "Once + Lock",
          thread_safe: true,
          short: "Инициализировать ровно один раз, потокобезопасно",
          etymology: `ONCE + LOCK = OnceLock.

ONCE — «один раз». Отсылка к pthread_once из POSIX: гарантирует что функция-инициализатор будет вызвана ровно один раз, даже если несколько потоков попытаются это сделать одновременно.

LOCK — «замок». Внутри используется механизм блокировки для атомарной инициализации.

OnceLock появился в Rust 1.70 как потокобезопасная замена LazyStatic (популярного crate). До этого был Once (без данных) — только сигнал «сделано/не сделано».

Эволюция: Once (1.0) → OnceLock<T> (1.70) → LazyLock<T> (1.80).

Аналоги: std::call_once (C++), sync.Once (Go).`,
          what: "Контейнер для значения, которое можно инициализировать ровно один раз. После — только чтение.",
          why: "Глобальные переменные, ленивая инициализация синглтонов, кеши, конфигурация.",
          how: "get_or_init(f) — атомарно инициализирует если ещё не было. Повторный вызов возвращает уже созданное значение.",
          danger: "Если инициализатор паникует — OnceLock остаётся не инициализированным, следующий вызов попробует снова.",
          example: `use std::sync::OnceLock;

static CONFIG: OnceLock<Vec<String>> = OnceLock::new();

fn get_config() -> &'static Vec<String> {
    CONFIG.get_or_init(|| {
        println!("Инициализация один раз!");
        vec!["host=localhost".to_string()]
    })
}

// Из любого потока, сколько угодно раз:
get_config(); // "Инициализация" — только первый раз
get_config(); // cached, println не вызывается`,
          interview: [
            "OnceLock vs Mutex? — OnceLock: write один раз при старте, потом только read без лока. Mutex: многократные write/read с локом каждый раз.",
            "OnceLock vs LazyLock? — LazyLock = OnceLock + автоматическая инициализация при первом доступе. OnceLock требует явного get_or_init.",
          ],
        },
      ],
    },
    {
      id: "traits",
      label: "Send & Sync трейты",
      color: "#f0c040",
      items: [
        {
          name: "Send",
          subtitle: "Маркерный трейт",
          thread_safe: true,
          short: "Тип можно передать в другой поток",
          etymology: `SEND = «отправить».

Маркерный трейт (marker trait) — без методов, только семантическая метка. Смысл: значение этого типа можно «отправить» (send) в другой поток — передать владение.

Почему «Send», а не «Movable» или «ThreadSafe»? Потому что конкретная операция — перемещение значения в другой поток через channel или spawn. «Send» — именно то что происходит.

thread::spawn требует F: Send. mpsc::Sender<T> требует T: Send. Это автоматически проверяется компилятором.

Большинство типов Send автоматически. Исключения: Rc<T> (счётчик не атомарный), raw pointers (*const T, *mut T), RefCell<T>.`,
          what: "Маркерный трейт. Значение типа T можно передать (move) в другой поток. Автоматически реализуется если все поля реализуют этот трейт.",
          why: "Фундамент системы типов Rust для безопасной многопоточности. thread::spawn принимает только замыкания реализующие этот трейт.",
          how: "Auto trait — реализуется автоматически. Если хотя бы одно поле не реализует трейт — тип тоже не реализует.",
          danger: "Ручная реализация unsafe impl Send — обещание компилятору. Ошибёшься — data race, UB.",
          example: `use std::thread;

// String: Send — можно отправить в поток
let s = String::from("hello");
thread::spawn(move || println!("{}", s));

// Rc: не Send — компилятор запретит:
// use std::rc::Rc;
// let rc = Rc::new(42);
// thread::spawn(move || println!("{}", rc));
// ERROR: Rc<i32> cannot be sent between threads safely`,
          interview: [
            "Send vs Sync? — Send: можно передать владение T в другой поток. Sync: можно безопасно иметь &T из разных потоков одновременно. T: Sync ⟺ &T: Send.",
            "Если T: Send, то Arc<T>: Send? — Arc<T>: Send если T: Send + Sync.",
            "Почему *mut T не Send? — Raw pointer не имеет гарантий — компилятор консервативно считает его небезопасным для потоков.",
          ],
        },
        {
          name: "Sync",
          subtitle: "Маркерный трейт",
          thread_safe: true,
          short: "На &T можно ссылаться из нескольких потоков",
          etymology: `SYNC = Synchronize — «синхронизировать».

Маркерный трейт означает: shared reference &T безопасно использовать одновременно из нескольких потоков. Тип «синхронизован» для параллельного доступа.

Математически: T: Sync ⟺ &T: Send. Это эквивалентное определение из документации Rust.

Почему «Sync», а не «SharedRef» или «ReadSafe»? «Sync» — короткое и ёмкое слово, традиционно означающее «работает правильно при параллельном выполнении».

Примеры не-Sync: Cell<T>, RefCell<T> — изменяют состояние через &self без синхронизации. Mutex<T> Sync потому что внутри есть синхронизация.`,
          what: "Маркерный трейт. &T можно безопасно использовать из нескольких потоков одновременно.",
          why: "Позволяет Arc<T> быть Send. Нужен для разделения данных между потоками через Arc.",
          how: "Auto trait — реализуется автоматически. Если хотя бы одно поле не реализует трейт — тип тоже не реализует.",
          danger: "RefCell<T> не Sync — Arc<RefCell<T>> не работает в многопоточке. Используй Arc<Mutex<T>>.",
          example: `// Arc<RefCell<T>>: НЕ работает в многопоточке
// RefCell не Sync → Arc<RefCell> не Sync → не Send
// Компилятор запретит thread::spawn

// Правильно: Arc<Mutex<T>>
use std::sync::{Arc, Mutex};
let shared = Arc::new(Mutex::new(vec![1, 2, 3]));
let s2 = Arc::clone(&shared);
std::thread::spawn(move || {
    s2.lock().unwrap().push(4);
});`,
          interview: [
            "Send vs Sync? — Send: перемещение T. Sync: разделённый &T. Оба нужны для Arc<T>.",
            "Mutex<T>: Sync даже если T не Sync? — Да! Mutex<T>: Sync для любого T: Send. Mutex сам обеспечивает синхронизацию.",
            "Можно ли самому реализовать Sync? — Да, через unsafe impl Sync. Это обещание компилятору что ты сам гарантируешь безопасность.",
          ],
        },
      ],
    },
    {
      id: "channels",
      label: "Каналы",
      color: "#c084fc",
      items: [
        {
          name: "mpsc",
          subtitle: "Multi-Producer Single-Consumer",
          thread_safe: true,
          short: "Передача сообщений между потоками",
          etymology: `MPSC = Multi-Producer Single-Consumer — «много производителей, один потребитель».

Это описание топологии канала: сколько отправителей и получателей он поддерживает.

Multi-Producer: Sender<T> можно клонировать — каждый клон отправляет в тот же канал.
Single-Consumer: Receiver<T> нельзя клонировать — один поток читает.

Аббревиатура MPSC — стандартный термин в CS. Для описания каналов используют MPSC/SPSC/MPMC.

Rust-каналы вдохновлены CSP (Communicating Sequential Processes, Тони Хоар, 1978) и Go-каналами. Философия: «не коммуницируй через общую память — разделяй память через коммуникацию».`,
          what: "Стандартный канал: много отправителей (Sender), один получатель (Receiver). Данные передаются по владению.",
          why: "Передача данных между потоками без Mutex. Часто безопаснее и читабельнее. Идиоматично для Rust.",
          how: "channel() → (Sender, Receiver). send() отправляет, recv() блокирует. sync_channel(N) — с буфером.",
          danger: "Receiver нельзя клонировать. channel() unbounded — возможна утечка памяти при переполнении.",
          example: `use std::sync::mpsc;
use std::thread;

let (tx, rx) = mpsc::channel::<i32>();
let tx2 = tx.clone(); // второй producer

thread::spawn(move || tx.send(1).unwrap());
thread::spawn(move || tx2.send(2).unwrap());

// for автоматически завершается когда все Sender дропнуты
for msg in rx {
    println!("{}", msg);
}`,
          interview: [
            "channel() vs sync_channel(N)? — channel(): unbounded, send() никогда не блокирует. sync_channel(N): буфер N, send() блокирует при переполнении (backpressure).",
            "Когда recv() возвращает Err? — Когда все Sender дропнуты. Это нормальный способ завершить for msg in rx.",
            "mpsc vs Arc<Mutex<Vec>>? — mpsc: данные перемещаются, нет гонок, нет deadlock. Mutex: изменяемое разделённое состояние, более гибко.",
            "Как сделать broadcast? — В std нет. Crates: tokio::broadcast, crossbeam-channel.",
          ],
        },
      ],
    },
  ],
  patterns: [
    { situation: "Readonly данные в нескольких потоках", solution: "Arc<T>", note: "T: Send + Sync" },
    { situation: "Mutable данные в нескольких потоках", solution: "Arc<Mutex<T>>", note: "Стандартный выбор" },
    { situation: "Много читателей, редкие записи", solution: "Arc<RwLock<T>>", note: "Лучше throughput при read >> write" },
    { situation: "Счётчик/флаг между потоками", solution: "Arc<AtomicUsize>", note: "Lock-free, самый быстрый" },
    { situation: "Передать данные между потоками", solution: "mpsc::channel()", note: "Предпочтительно перед Mutex" },
    { situation: "Разделить владение, один поток", solution: "Rc<T>", note: "Дешевле Arc" },
    { situation: "Мутация через &self, один поток", solution: "RefCell<T>", note: "Borrow checking в рантайме" },
    { situation: "Разделить владение + мутация, 1 поток", solution: "Rc<RefCell<T>>", note: "Классическая пара для однопоточки" },
    { situation: "Разделить владение + мутация, N потоков", solution: "Arc<Mutex<T>>", note: "Классическая пара для многопоточки" },
    { situation: "Глобальная ленивая инициализация", solution: "OnceLock<T>", note: "Или LazyLock<T> в Rust 1.80+" },
    { situation: "Дождаться всех потоков (fork-join)", solution: "Barrier", note: "Точка встречи N потоков" },
    { situation: "Обратная ссылка (дерево, граф)", solution: "Weak<T>", note: "Разрыв циклов Rc/Arc" },
  ],
  etymology_overview: [
    { name: "Rc", full: "Reference Counted", origin: "CS 1960-е", idea: "Счётчик ссылок — классика GC. Python, C++ shared_ptr" },
    { name: "Arc", full: "Atomic Reference Counted", origin: "= Rc + Atomic", idea: "Rc с атомарным счётчиком для thread-safety" },
    { name: "Weak", full: "Weak Reference", origin: "Теория GC", idea: "Слабая vs сильная ссылка. Не продлевает жизнь объекта" },
    { name: "Cell", full: "Mutable Cell", origin: "Биологическая метафора", idea: "Непрозрачная ячейка. Только set/get целиком, без ссылок внутрь" },
    { name: "RefCell", full: "Ref + Cell", origin: "= Reference + Cell", idea: "Ячейка которая выдаёт ссылки. Borrow-чек в рантайме" },
    { name: "Mutex", full: "Mutual Exclusion", origin: "Дейкстра, 1965", idea: "Взаимное исключение. Термин с 1960-х, используется везде" },
    { name: "RwLock", full: "Read-Write Lock", origin: "POSIX pthread_rwlock", idea: "Два режима: shared читатели vs exclusive писатель" },
    { name: "Condvar", full: "Condition Variable", origin: "Хоар, 1974 (Monitors)", idea: "Ждать условия. Всегда в паре с Mutex" },
    { name: "Atomic", full: "Atomic operation", origin: "atomos (греч.) — неделимый", idea: "CPU-инструкция LOCK XADD — физически неделимая" },
    { name: "Barrier", full: "Synchronization Barrier", origin: "HPC / параллельные вычисления", idea: "Физическая метафора: все бегут к барьеру и ждут" },
    { name: "OnceLock", full: "Once + Lock", origin: "POSIX pthread_once", idea: "Инициализировать ровно один раз атомарно" },
    { name: "mpsc", full: "Multi-Producer Single-Consumer", origin: "CSP Хоара, 1978", idea: "Топология канала. Вдохновение: Go-каналы" },
    { name: "Send", full: "Send (marker trait)", origin: "Rust 1.0", idea: "Отправить владение в другой поток" },
    { name: "Sync", full: "Synchronize (marker trait)", origin: "Rust 1.0", idea: "T: Sync ⟺ &T: Send. Безопасный shared access" },
  ],
};

// ─── state ─────────────────────────────────────────────────────────────────
const state = {
  view: 'cards',
  activeCategory: 'ownership',
  activeItem: null,
  tab: 'what',
  sidebarOpen: false,
  isMobile: window.innerWidth < 600,
  quiz: {
    phase: 'setup',
    deck: [],
    index: 0,
    knownIds: [],
    unknownIds: [],
    selCats: null,
    selFmts: null,
  }
};

window.addEventListener('resize', () => {
  const was = state.isMobile;
  state.isMobile = window.innerWidth < 600;
  if (was !== state.isMobile) render();
});

function set(patch) { Object.assign(state, patch); render(); }
function setQ(patch) { Object.assign(state.quiz, patch); render(); }

// ─── helpers ───────────────────────────────────────────────────────────────
function esc(s) {
  return String(s == null ? '' : s)
    .replace(/&/g,'&amp;').replace(/</g,'&lt;')
    .replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;');
}
function shuffle(arr) {
  const a = [...arr];
  for (let i = a.length-1; i > 0; i--) {
    const j = Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];
  }
  return a;
}

// ─── card formats ──────────────────────────────────────────────────────────
const FMTS = [
  { id:'name_what',   label:'Название → Что это?',
    front: i=>({q:'Что это такое?',                  v:i.name,    hint:null}),
    back:  i=>({q:'Определение',                     v:i.what}) },
  { id:'what_name',   label:'Определение → Название',
    front: i=>({q:'Это определение какого типа?',    v:i.what,    hint:null}),
    back:  i=>({q:'Тип',                             v:i.name,    hint:i.subtitle}) },
  { id:'name_why',    label:'Название → Зачем?',
    front: i=>({q:'Когда и зачем используется?',     v:i.name,    hint:null}),
    back:  i=>({q:'Use-case',                        v:i.why}) },
  { id:'why_name',    label:'Use-case → Название',
    front: i=>({q:'Для этой задачи — какой тип?',   v:i.why,     hint:null}),
    back:  i=>({q:'Тип',                             v:i.name,    hint:i.subtitle}) },
  { id:'name_how',    label:'Название → Как работает?',
    front: i=>({q:'Как это работает внутри?',        v:i.name,    hint:null}),
    back:  i=>({q:'Механизм',                        v:i.how}) },
  { id:'how_name',    label:'Механизм → Название',
    front: i=>({q:'Что это за механизм?',            v:i.how,     hint:null}),
    back:  i=>({q:'Тип',                             v:i.name,    hint:i.subtitle}) },
  { id:'name_danger', label:'Название → Опасности',
    front: i=>({q:'Какие подводные камни?',          v:i.name,    hint:null}),
    back:  i=>({q:'⚠ Опасности',                    v:i.danger}) },
  { id:'short_name',  label:'Краткое описание → Название',
    front: i=>({q:'Что это за тип?',                 v:i.short,   hint:null}),
    back:  i=>({q:'Тип',                             v:i.name,    hint:i.subtitle}) },
  { id:'etym_name',   label:'Расшифровка → Название',
    front: i=>({q:'Назови тип по расшифровке:',      v:i.subtitle,hint:null}),
    back:  i=>({q:'Тип',                             v:i.name,    hint:i.short}) },
  { id:'name_etym',   label:'Название → Расшифровка',
    front: i=>({q:'Расшифруй название:',             v:i.name,    hint:null}),
    back:  i=>({q:'Расшифровка',                     v:i.subtitle,hint:i.short}) },
];

function buildDeck(selCats, selFmts) {
  const items = data.categories
    .filter(c => selCats.includes(c.id))
    .flatMap(c => c.items.map(i => ({...i, catColor:c.color})));
  const fmts = FMTS.filter(f => selFmts.includes(f.id));
  return shuffle(items.flatMap(it => fmts.map(fmt =>
    ({item:it, fmt, id:it.name+'|'+fmt.id, flipped:false})
  )));
}

// ─── TAB labels ────────────────────────────────────────────────────────────
const TABS = {what:'Что это?',why:'Зачем?',how:'Как работает',
              etymology:'Название',danger:'⚠ Опасности',example:'Код',interview:'Вопросы'};

// ─── RENDER ─────────────────────────────────────────────────────────────────
function render() {
  document.getElementById('app').innerHTML = buildHTML();
}

function buildHTML() {
  const m = state.isMobile;
  const v = state.view;
  if (v === 'quiz')      return header() + quizSubHeader() + quizBody();
  if (v === 'patterns')  return header() + patterns();
  if (v === 'etymology') return header() + etymology();
  // cards
  if (m) return header() + drawer() + `<div>${state.activeItem ? itemDetail() : cardsGrid()}</div>`;
  return header() + `<div style="display:flex;height:calc(100vh - 52px)">
    <div style="width:200px;border-right:1px solid #1e2330;padding:12px 0;overflow-y:auto;flex-shrink:0">${sidebar()}</div>
    <div style="flex:1;overflow-y:auto">${state.activeItem ? itemDetail() : cardsGrid()}</div>
  </div>`;
}

// ─── HEADER ─────────────────────────────────────────────────────────────────
function header() {
  const m = state.isMobile;
  const v = state.view;
  const inQuiz = v === 'quiz';

  let leftBtn = '';
  if (inQuiz) {
    leftBtn = `<button da="quiz-back" style="${btnBase()};color:#4a9eff;background:none;border:none;font-size:${m?14:13}px">←</button>`;
  } else if (m && v === 'cards' && state.activeItem) {
    leftBtn = `<button da="item-back" style="${btnBase()};color:#4a9eff;background:none;border:none;font-size:18px">←</button>`;
  } else if (m && v === 'cards' && !state.activeItem) {
    leftBtn = `<button da="sidebar-toggle" style="${btnBase()};color:#4a9eff;background:none;border:none;font-size:18px">☰</button>`;
  }

  const navItems = [['cards','Типы'],['patterns','Паттерны'],['etymology','Этимология']];
  const navBtns = inQuiz ? '' : navItems.map(([id, lbl]) => {
    const active = v === id;
    return `<button da="nav" dv="${id}" style="${btnBase()};
      padding:${m?'4px 7px':'5px 11px'};font-size:${m?10:11}px;
      background:${active?'#1e2330':'transparent'};
      border:1px solid ${active?'#4a9eff':'#2a3040'};
      border-radius:6px;color:${active?'#4a9eff':'#6b7a94'}">${lbl}</button>`;
  }).join('');

  const quizBtn = inQuiz ? '' : `<button da="nav" dv="quiz" style="${btnBase()};
    padding:${m?'4px 7px':'5px 11px'};font-size:${m?10:11}px;font-weight:700;
    background:#0d0a18;border:1px solid #c084fc;border-radius:6px;color:#c084fc">
    🃏${m?'':' Карточки'}</button>`;

  return `<div style="border-bottom:1px solid #1e2330;padding:${m?'11px 14px':'12px 22px'};
    display:flex;align-items:center;gap:8px;position:sticky;top:0;z-index:100;background:#0d0f14">
    ${leftBtn}
    <div style="font-size:${m?15:18}px;font-weight:800;letter-spacing:-1px">
      <span style="color:#e8793a">Rust</span><span style="color:#4a9eff">::concurrency</span>
    </div>
    <div style="margin-left:auto;display:flex;gap:5px;align-items:center">
      ${navBtns}${quizBtn}
    </div>
  </div>`;
}

function btnBase() { return 'cursor:pointer;font-family:inherit'; }

// ─── SIDEBAR ────────────────────────────────────────────────────────────────
function sidebar() {
  const m = state.isMobile;
  return data.categories.map(cat => {
    const rows = cat.items.map(it => {
      const active = state.activeItem === it.name && state.activeCategory === cat.id;
      return `<div da="open-item" dc="${cat.id}" di="${esc(it.name)}" style="
        padding:${m?'10px 14px':'7px 14px'};cursor:pointer;display:flex;align-items:center;gap:7px;
        background:${active?'#111d2c':'transparent'};
        border-left:3px solid ${active?cat.color:'transparent'}">
        <span style="font-size:${m?14:12}px;font-weight:700;color:${cat.color}">${esc(it.name)}</span>
        <span style="font-size:9px;background:${it.thread_safe?'#0d2a1a':'#2a1a0d'};
          color:${it.thread_safe?'#6bcf7f':'#e8793a'};border-radius:3px;padding:1px 4px">
          ${it.thread_safe?'MT':'ST'}</span>
      </div>`;
    }).join('');
    return `<div style="font-size:9px;font-weight:700;color:#3d4a60;
      padding:7px 14px 3px;letter-spacing:1px;text-transform:uppercase">${esc(cat.label)}</div>${rows}`;
  }).join('');
}

function drawer() {
  const open = state.sidebarOpen;
  return `
    <div da="sidebar-close" style="position:fixed;inset:0;background:rgba(0,0,0,.6);z-index:200;
      pointer-events:${open?'auto':'none'};opacity:${open?1:0};transition:opacity .2s"></div>
    <div style="position:fixed;top:0;left:0;bottom:0;width:78vw;max-width:300px;
      background:#0d0f14;border-right:1px solid #1e2330;z-index:300;overflow-y:auto;padding:16px 0;
      transform:${open?'translateX(0)':'translateX(-100%)'};transition:transform .22s ease">
      <div style="padding:0 14px 12px;font-size:13px;font-weight:800;color:#6b7a94;
        border-bottom:1px solid #1e2330;margin-bottom:6px">Выбери тип</div>
      ${sidebar()}
    </div>`;
}

// ─── PATTERNS ───────────────────────────────────────────────────────────────
function patterns() {
  const m = state.isMobile;
  const rows = data.patterns.map(p => `
    <div style="background:#111420;border:1px solid #1e2330;border-radius:9px;
      padding:${m?'10px 12px':'12px 18px'};display:grid;
      grid-template-columns:${m?'1fr':'1fr 24px 1fr'};gap:${m?4:10}px;align-items:center">
      <div style="font-size:12px;color:#8a9ab5">${esc(p.situation)}</div>
      ${m?'':'<div style="color:#3d4a60;text-align:center">→</div>'}
      <div style="display:flex;align-items:center;gap:6px;flex-wrap:wrap">
        ${m?'<span style="color:#3d4a60;font-size:11px">→</span>':''}
        <span style="font-size:${m?14:15}px;font-weight:700;color:#6bcf7f">${esc(p.solution)}</span>
        <span style="font-size:10px;color:#6b7a94">${esc(p.note)}</span>
      </div>
    </div>`).join('');
  return `<div style="padding:${m?'14px':'22px'};max-width:860px;margin:0 auto">
    <div style="font-size:11px;color:#6b7a94;margin-bottom:14px">Задача → правильный инструмент</div>
    <div style="display:grid;gap:7px">${rows}</div>
  </div>`;
}

// ─── ETYMOLOGY ──────────────────────────────────────────────────────────────
function etymology() {
  const m = state.isMobile;
  const rows = data.etymology_overview.map(e => `
    <div style="background:#111420;border:1px solid #1e2330;border-radius:9px;
      padding:${m?'10px 12px':'12px 18px'};display:grid;
      grid-template-columns:${m?'65px 1fr':'80px 190px 1fr'};gap:${m?8:14}px;align-items:start">
      <div style="font-size:${m?13:14}px;font-weight:800;color:#e8793a">${esc(e.name)}</div>
      ${m ? `<div>
        <div style="font-size:11px;color:#4a9eff;margin-bottom:2px">${esc(e.full)}</div>
        <div style="font-size:11px;color:#8a9ab5;line-height:1.5;margin-top:3px">${esc(e.idea)}</div>
        <div style="font-size:10px;color:#3d4a60;margin-top:2px">${esc(e.origin)}</div>
      </div>` : `
        <div>
          <div style="font-size:11px;color:#4a9eff;margin-bottom:2px">${esc(e.full)}</div>
          <div style="font-size:10px;color:#3d4a60">${esc(e.origin)}</div>
        </div>
        <div style="font-size:12px;color:#8a9ab5;line-height:1.5">${esc(e.idea)}</div>`}
    </div>`).join('');
  return `<div style="padding:${m?'14px':'22px'};max-width:1000px;margin:0 auto">
    <div style="font-size:11px;color:#6b7a94;margin-bottom:14px">Почему типы называются именно так</div>
    <div style="display:grid;gap:7px">${rows}</div>
    <div style="margin-top:16px;background:#0a1628;border-left:4px solid #4a9eff;border-radius:8px;
      padding:${m?'12px 14px':'14px 18px'};font-size:12px;color:#8a9ab5;line-height:1.9">
      <span style="color:#4a9eff;font-weight:700">Паттерн именования в Rust: </span>
      имена раскрывают механизм реализации, а не абстрактное назначение.<br>
      Rc = Reference Counted, Arc = Atomic + Rc, RefCell = Ref + Cell, OnceLock = Once + Lock.<br>
      <span style="color:#f0c040">Совет для собеседования: </span>знаешь расшифровку — уже понятно как это работает.
    </div>
  </div>`;
}

// ─── CARDS GRID ─────────────────────────────────────────────────────────────
function cardsGrid() {
  const m = state.isMobile;
  const cards = data.categories.flatMap(cat =>
    cat.items.map(it => `
      <div da="open-item" dc="${cat.id}" di="${esc(it.name)}" style="
        background:#111420;border:1px solid #1e2330;border-top:3px solid ${cat.color};
        border-radius:10px;padding:${m?'11px 12px':'14px 16px'};cursor:pointer">
        <div style="display:flex;align-items:center;gap:6px;margin-bottom:4px;flex-wrap:wrap">
          <span style="font-size:${m?13:15}px;font-weight:800;color:${cat.color}">${esc(it.name)}</span>
          <span style="font-size:9px;background:${it.thread_safe?'#0d2a1a':'#2a1a0d'};
            color:${it.thread_safe?'#6bcf7f':'#e8793a'};border-radius:3px;padding:1px 4px">
            ${it.thread_safe?'MT':'ST'}</span>
        </div>
        ${m?'':'<div style="font-size:10px;color:#6b7a94;margin-bottom:3px">'+esc(it.subtitle)+'</div>'}
        <div style="font-size:11px;color:#8a9ab5;line-height:1.4">${esc(it.short)}</div>
      </div>`)
  ).join('');
  return `<div style="padding:${m?'14px':'20px 24px'};display:grid;
    grid-template-columns:${m?'1fr 1fr':'repeat(auto-fill,minmax(230px,1fr))'};gap:${m?9:11}px">
    ${cards}</div>`;
}

// ─── ITEM DETAIL ────────────────────────────────────────────────────────────
function itemDetail() {
  const m = state.isMobile;
  const cat = data.categories.find(c => c.id === state.activeCategory);
  const item = cat.items.find(i => i.name === state.activeItem);

  const tabBtns = Object.entries(TABS).map(([k, lbl]) => {
    const active = state.tab === k;
    return `<button da="set-tab" dv="${k}" style="${btnBase()};
      padding:5px 10px;border-radius:6px;border:1px solid;
      font-size:11px;white-space:nowrap;flex-shrink:0;
      background:${active?cat.color+'28':'transparent'};
      border-color:${active?cat.color:'#2a3040'};
      color:${active?cat.color:'#6b7a94'}">${lbl}</button>`;
  }).join('');

  let body = '';
  if (state.tab === 'example') {
    body = `<pre style="margin:0;font-size:${m?11:12}px;line-height:1.7;color:#c8d0e0;overflow-x:auto;white-space:pre"><code>${esc(item.example)}</code></pre>`;
  } else if (state.tab === 'interview') {
    body = item.interview.map(q => {
      const sep = q.indexOf('? — ');
      const question = sep >= 0 ? q.slice(0,sep)+'?' : q;
      const answer = sep >= 0 ? q.slice(sep+4) : '';
      return `<div style="border-left:3px solid #c084fc;padding-left:12px">
        <div style="color:#c084fc;font-weight:700;margin-bottom:4px;font-size:12px">❓ ${esc(question)}</div>
        ${answer?`<div style="color:#8a9ab5;font-size:12px;line-height:1.7">${esc(answer)}</div>`:''}
      </div>`;
    }).join('');
    body = `<div style="display:grid;gap:14px">${body}</div>`;
  } else {
    const prefix = state.tab==='danger'?'<span style="color:#e8793a;margin-right:6px">⚠</span>':'';
    body = `<div style="font-size:${m?13:12}px;line-height:2;color:#8a9ab5;white-space:pre-wrap">${prefix}${esc(item[state.tab]||'')}</div>`;
  }

  const related = data.categories.flatMap(c => c.items.map(i => ({...i, catColor:c.color, catId:c.id})))
    .filter(i => i.name !== item.name).slice(0,6)
    .map(r => `<div da="open-item" dc="${r.catId}" di="${esc(r.name)}" style="
      background:#0d0f14;border:1px solid #1e2330;border-radius:6px;
      padding:6px 11px;cursor:pointer;font-size:11px">
      <span style="color:${r.catColor};font-weight:700">${esc(r.name)}</span>
    </div>`).join('');

  return `<div style="padding:${m?'14px':'20px 24px'}">
    <div style="margin-bottom:14px;display:flex;align-items:center;gap:8px;flex-wrap:wrap">
      ${!m?`<button da="item-back" style="${btnBase()};background:none;border:none;color:#4a9eff;font-size:11px">← Все</button>
        <span style="color:#3d4a60">/</span>`:''}
      <span style="font-size:${m?18:20}px;font-weight:800;color:${cat.color}">${esc(item.name)}</span>
      <span style="font-size:${m?11:12}px;color:#6b7a94">${esc(item.subtitle)}</span>
      <span style="font-size:10px;background:${item.thread_safe?'#0d2a1a':'#2a1a0d'};
        color:${item.thread_safe?'#6bcf7f':'#e8793a'};border-radius:5px;padding:3px 9px;margin-left:auto">
        ${item.thread_safe?'✓ Thread-Safe':'✗ Single Thread'}</span>
    </div>
    <div style="background:#0a1628;border-left:4px solid ${cat.color};border-radius:8px;
      padding:10px 14px;margin-bottom:14px;font-size:13px;color:#c8d0e0">${esc(item.short)}</div>
    <div style="display:flex;gap:5px;margin-bottom:14px;overflow-x:auto;padding-bottom:2px">${tabBtns}</div>
    <div style="background:#111420;border:1px solid #1e2330;border-radius:10px;padding:${m?'13px 14px':'16px 20px'}">${body}</div>
    <div style="display:flex;gap:7px;margin-top:14px;flex-wrap:wrap">${related}</div>
  </div>`;
}

// ─── QUIZ ───────────────────────────────────────────────────────────────────
function quizSubHeader() {
  const m = state.isMobile;
  const q = state.quiz;
  const extra = q.phase==='playing' ? `
    <span style="color:#1e2330">|</span>
    <button da="quiz-setup" style="${btnBase()};background:none;border:none;color:#6b7a94;font-size:12px">настройки</button>
    <div style="margin-left:auto;display:flex;gap:14px;font-size:12px">
      <span style="color:#6bcf7f">✓ ${q.knownIds.length}</span>
      <span style="color:#e8793a">✗ ${q.unknownIds.length}</span>
    </div>` : '';
  return `<div style="border-bottom:1px solid #1e2330;padding:${m?'8px 14px':'8px 22px'};
    display:flex;align-items:center;gap:10px;background:#0d0f14">
    <button da="quiz-back" style="${btnBase()};background:none;border:none;color:#6b7a94;font-size:12px">← к справочнику</button>
    ${extra}
  </div>`;
}

function quizBody() {
  const q = state.quiz;
  if (q.phase === 'setup')   return quizSetup();
  if (q.phase === 'playing') return quizCard();
  return quizResults();
}

function quizSetup() {
  const m = state.isMobile;
  const q = state.quiz;
  const allCatIds = data.categories.map(c => c.id);
  const allFmtIds = FMTS.map(f => f.id);
  const selCats = q.selCats || allCatIds;
  const selFmts = q.selFmts || allFmtIds;

  const catBtns = data.categories.map(cat => {
    const on = selCats.includes(cat.id);
    return `<button da="toggle-cat" dv="${cat.id}" style="${btnBase()};
      padding:7px 12px;border-radius:8px;
      border:1px solid ${on?cat.color:'#2a3040'};
      background:${on?cat.color+'18':'transparent'};
      color:${on?cat.color:'#6b7a94'};font-size:12px;font-weight:600">
      ${esc(cat.label)} (${cat.items.length})</button>`;
  }).join('');

  const fmtBtns = FMTS.map(fmt => {
    const on = selFmts.includes(fmt.id);
    return `<button da="toggle-fmt" dv="${fmt.id}" style="${btnBase()};
      padding:7px 11px;border-radius:8px;text-align:left;
      border:1px solid ${on?'#4a9eff':'#2a3040'};
      background:${on?'#0a1628':'transparent'};
      color:${on?'#4a9eff':'#6b7a94'};font-size:11px">
      ${on?'✓':'○'} ${esc(fmt.label)}</button>`;
  }).join('');

  const itemCount = data.categories.filter(c => selCats.includes(c.id)).flatMap(c=>c.items).length;
  const cardCount = itemCount * selFmts.length;

  return `<div style="padding:${m?'16px':'28px'};max-width:680px;margin:0 auto">
    <div style="font-size:${m?18:22}px;font-weight:800;color:#c8d0e0;margin-bottom:6px">🃏 Режим карточек</div>
    <div style="font-size:13px;color:#6b7a94;margin-bottom:22px;line-height:1.7">
      Настрой колоду и тренируй память. Форматы чередуются — каждый тип учится с разных сторон.
    </div>
    <div style="margin-bottom:20px">
      <div style="font-size:11px;color:#6b7a94;margin-bottom:10px;text-transform:uppercase;letter-spacing:1px">
        Категории
        <button da="all-cats" style="${btnBase()};margin-left:10px;background:none;border:none;color:#4a9eff;font-size:10px">
          ${selCats.length===allCatIds.length?'снять все':'выбрать все'}</button>
      </div>
      <div style="display:flex;flex-wrap:wrap;gap:8px">${catBtns}</div>
    </div>
    <div style="margin-bottom:24px">
      <div style="font-size:11px;color:#6b7a94;margin-bottom:10px;text-transform:uppercase;letter-spacing:1px">
        Типы вопросов
        <button da="all-fmts" style="${btnBase()};margin-left:10px;background:none;border:none;color:#4a9eff;font-size:10px">
          ${selFmts.length===allFmtIds.length?'снять все':'выбрать все'}</button>
      </div>
      <div style="display:grid;grid-template-columns:${m?'1fr':'1fr 1fr'};gap:7px">${fmtBtns}</div>
    </div>
    <div style="background:#111420;border-radius:10px;padding:16px 18px;
      display:flex;align-items:center;gap:14px;flex-wrap:wrap">
      <div>
        <div style="font-size:24px;font-weight:800;color:#c8d0e0">${cardCount}</div>
        <div style="font-size:11px;color:#6b7a94">карточек в колоде</div>
      </div>
      <div style="font-size:11px;color:#3d4a60;flex:1">${itemCount} типов × ${selFmts.length} форматов</div>
      <button da="start-quiz" ${cardCount>0?'':'disabled'} style="${btnBase()};
        padding:12px 24px;border-radius:10px;border:none;
        background:${cardCount>0?'#4a9eff':'#1e2330'};
        color:${cardCount>0?'#0d0f14':'#3d4a60'};
        cursor:${cardCount>0?'pointer':'not-allowed'};
        font-size:14px;font-weight:800">Начать →</button>
    </div>
  </div>`;
}

// Redact the type name so it doesn't spoil the answer.
// Handles: exact name, lowercase, compound names starting with base (MutexGuard→Mutex)
function redact(text, itemName) {
  if (!text) return text;
  const base = itemName.replace(/<[^>]*>/, '').trim(); // "Rc<T>" → "Rc"
  if (!base) return text;
  const e = base.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  const lower = base.toLowerCase();
  const el = lower.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  let result = text;
  // 1. Exact base: as standalone word OR before :: < uppercase-continuation
  //    e.g. "Rc", "Rc::new", "Rc<T>", "RcWeak" but NOT inside "Arc"
  result = result.replace(new RegExp('(?<![A-Za-z])' + e + '(?=[^a-z]|$)', 'g'), '░░░');
  // 2. Lowercase as variable name after & or let/mut keyword
  result = result.replace(new RegExp('(&|\\blet mut\\s+|\\blet\\s+)' + el + '\\b', 'g'), '$1░░░');
  return result;
}

function quizCard() {
  const m = state.isMobile;
  const q = state.quiz;
  const card = q.deck[q.index];
  const {item, fmt, flipped} = card;
  const front = fmt.front(item);
  const back  = fmt.back(item);
  const pct = (q.index / q.deck.length) * 100;

  // If the answer is the type name, censor it from the question text
  const answerIsName = back.v === item.name;
  const frontText = answerIsName ? redact(front.v, item.name) : front.v;
  return `<div style="padding:${m?'14px':'28px'};max-width:600px;margin:0 auto;display:flex;flex-direction:column;gap:14px">
    <div style="display:flex;align-items:center;gap:10px">
      <div style="flex:1;height:3px;background:#1e2330;border-radius:2px;overflow:hidden">
        <div style="height:100%;background:#4a9eff;width:${pct}%;transition:width 0.3s"></div>
      </div>
      <span style="font-size:11px;color:#6b7a94;flex-shrink:0">${q.index+1} / ${q.deck.length}</span>
    </div>

    <div da="flip-card" style="
      background:#111420;border:1px solid #2a3040;border-radius:14px;
      padding:${m?'18px 16px':'26px 30px'};min-height:${m?200:260}px;
      display:flex;flex-direction:column;cursor:pointer;user-select:none;
      -webkit-tap-highlight-color:transparent">

      <!-- FRONT: question -->
      <div>
        <div style="font-size:10px;color:#6b7a94;margin-bottom:8px;
          text-transform:uppercase;letter-spacing:0.5px">${esc(front.q)}</div>
        <div style="font-size:${m?15:18}px;font-weight:700;color:#c8d0e0;line-height:1.5">${esc(frontText)}</div>
      </div>

      ${flipped ? `
        <!-- BACK: answer revealed -->
        <div style="border-top:1px solid #1e2330;padding-top:16px;margin-top:16px">
          <div style="font-size:10px;color:#6bcf7f;margin-bottom:6px;text-transform:uppercase;letter-spacing:0.5px">
            ✓ ${esc(back.q)}</div>
          <div style="font-size:${m?15:16}px;font-weight:700;color:#6bcf7f;line-height:1.5">${esc(back.v)}</div>
          ${back.hint?`<div style="font-size:11px;color:#4a9eff;margin-top:6px">${esc(back.hint)}</div>`:''}
          <div style="font-size:11px;color:#6b7a94;margin-top:10px">${esc(item.short)}</div>
        </div>` :
        `<div style="margin-top:auto;text-align:center;font-size:12px;color:#2a3040;padding-top:16px">
          нажми чтобы увидеть ответ</div>`}
    </div>

    <div style="display:flex;gap:10px">
      <button da="dont-know" style="${btnBase()};flex:1;padding:${m?13:14}px;border-radius:10px;
        border:1px solid #e8793a44;background:#1a100a;color:#e8793a;
        font-size:${m?13:14}px;font-weight:600">✗ Не знаю</button>
      <button da="do-know" ${flipped?'':'disabled'} style="${btnBase()};flex:1;padding:${m?13:14}px;border-radius:10px;
        border:1px solid #6bcf7f44;
        background:${flipped?'#0a1a0e':'#0d0f14'};
        color:${flipped?'#6bcf7f':'#2a3040'};
        cursor:${flipped?'pointer':'not-allowed'};
        font-size:${m?13:14}px;font-weight:600">✓ Знаю</button>
    </div>
    <div style="font-size:10px;color:#2a3040;text-align:center">«Знаю» доступно только после просмотра ответа</div>
  </div>`;
}

function quizResults() {
  const m = state.isMobile;
  const q = state.quiz;
  const known = q.knownIds.length, unknown = q.unknownIds.length, total = q.deck.length;
  const pct = Math.round((known/total)*100);
  const emoji = pct===100?'🎉':pct>=70?'💪':pct>=40?'📚':'🔁';
  const msg = pct===100?'Отлично!':pct>=70?'Хороший результат':pct>=40?'Есть над чем работать':'Продолжай учиться';
  return `<div style="padding:${m?'20px 16px':'40px'};max-width:500px;margin:0 auto;text-align:center">
    <div style="font-size:${m?40:52}px;margin-bottom:8px">${emoji}</div>
    <div style="font-size:${m?22:28}px;font-weight:800;color:#c8d0e0;margin-bottom:6px">${msg}</div>
    <div style="font-size:14px;color:#6b7a94;margin-bottom:24px">${known} из ${total} карточек</div>
    <div style="background:#111420;border-radius:12px;padding:18px 20px;margin-bottom:20px;text-align:left">
      <div style="display:flex;justify-content:space-between;margin-bottom:10px">
        <span style="font-size:13px;color:#6bcf7f">✓ Знаю — ${known}</span>
        <span style="font-size:13px;color:#e8793a">✗ Не знаю — ${unknown}</span>
      </div>
      <div style="height:8px;background:#1e2330;border-radius:4px;overflow:hidden">
        <div style="height:100%;background:linear-gradient(90deg,#6bcf7f,#4a9eff);width:${pct}%"></div>
      </div>
    </div>
    <div style="display:flex;flex-direction:column;gap:10px">
      ${unknown>0?`<button da="restart-unknown" style="${btnBase()};padding:13px;border-radius:10px;
        border:1px solid #4a9eff44;background:#0a1628;color:#4a9eff;font-size:14px;font-weight:600">
        🔁 Повторить незнакомые (${unknown})</button>`:''}
      <button da="restart-all" style="${btnBase()};padding:13px;border-radius:10px;
        border:1px solid #2a3040;background:#111420;color:#8a9ab5;font-size:14px;font-weight:600">
        Начать заново (все ${total})</button>
      <button da="quiz-setup" style="${btnBase()};padding:13px;border-radius:10px;
        border:1px solid #2a3040;background:transparent;color:#6b7a94;font-size:14px">
        ⚙ Настроить колоду</button>
    </div>
  </div>`;
}

// ─── EVENTS — single persistent delegated listener ──────────────────────────
document.addEventListener('click', function(e) {
  // Walk up DOM tree from click target, find first element with 'da' attribute
  let el = e.target;
  while (el && el.tagName !== 'HTML') {
    const action = el.getAttribute('da');
    if (action) {
      e.stopPropagation();
      handle(action, el, e);
      return;
    }
    el = el.parentElement;
  }
});

function handle(action, el, e) {
  const q = state.quiz;
  const allCatIds = data.categories.map(c => c.id);
  const allFmtIds = FMTS.map(f => f.id);
  const selCats = () => q.selCats || allCatIds;
  const selFmts = () => q.selFmts || allFmtIds;

  switch(action) {
    case 'nav': {
      const v = el.getAttribute('dv');
      // init quiz defaults when entering quiz first time
      if (v === 'quiz' && !q.selCats) setQ({ selCats: allCatIds, selFmts: allFmtIds, phase: 'setup' });
      set({ view: v, activeItem: null, sidebarOpen: false });
      break;
    }
    case 'quiz-back':
      set({ view: 'cards', activeItem: null, sidebarOpen: false });
      break;
    case 'item-back':
      set({ activeItem: null });
      break;
    case 'sidebar-toggle':
      set({ sidebarOpen: !state.sidebarOpen });
      break;
    case 'sidebar-close':
      set({ sidebarOpen: false });
      break;
    case 'open-item':
      set({ activeCategory: el.getAttribute('dc'), activeItem: el.getAttribute('di'), tab:'what', sidebarOpen:false });
      break;
    case 'set-tab':
      set({ tab: el.getAttribute('dv') });
      break;

    case 'toggle-cat': {
      const id = el.getAttribute('dv');
      const cur = selCats();
      setQ({ selCats: cur.includes(id) ? cur.filter(x=>x!==id) : [...cur,id] });
      break;
    }
    case 'toggle-fmt': {
      const id = el.getAttribute('dv');
      const cur = selFmts();
      setQ({ selFmts: cur.includes(id) ? cur.filter(x=>x!==id) : [...cur,id] });
      break;
    }
    case 'all-cats':
      setQ({ selCats: selCats().length===allCatIds.length ? [] : allCatIds });
      break;
    case 'all-fmts':
      setQ({ selFmts: selFmts().length===allFmtIds.length ? [] : allFmtIds });
      break;
    case 'start-quiz': {
      const deck = buildDeck(selCats(), selFmts());
      setQ({ phase:'playing', deck, index:0, knownIds:[], unknownIds:[] });
      break;
    }
    case 'flip-card': {
      // Mark current card as flipped (mutate deck array item)
      const deck = q.deck.map((c,i) => i===q.index ? {...c, flipped:true} : c);
      setQ({ deck });
      break;
    }
    case 'do-know': {
      if (!q.deck[q.index].flipped) return; // guard: must flip first
      const knownIds = [...q.knownIds, q.deck[q.index].id];
      const next = q.index + 1;
      setQ(next >= q.deck.length ? { knownIds, phase:'results' } : { knownIds, index:next });
      break;
    }
    case 'dont-know': {
      const unknownIds = [...q.unknownIds, q.deck[q.index].id];
      const next = q.index + 1;
      setQ(next >= q.deck.length ? { unknownIds, phase:'results' } : { unknownIds, index:next });
      break;
    }
    case 'restart-all': {
      const deck = shuffle(q.deck.map(c=>({...c,flipped:false})));
      setQ({ phase:'playing', deck, index:0, knownIds:[], unknownIds:[] });
      break;
    }
    case 'restart-unknown': {
      const deck = shuffle(q.deck.filter(c=>q.unknownIds.includes(c.id)).map(c=>({...c,flipped:false})));
      setQ({ phase:'playing', deck, index:0, knownIds:[], unknownIds:[] });
      break;
    }
    case 'quiz-setup':
      setQ({ phase:'setup' });
      break;
  }
}

render();

  </script>
</body>
</html>